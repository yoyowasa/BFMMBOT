def cap_order_size_by_inventory(
    req_raw: float,
    abs_q: float,
    eff_limit: float,
    min_lot: float,
    target_ratio: float = 0.90,
) -> float:
    """
    在庫と新規サイズの合計が target_ratio*eff_limit を超えないように、
    最小ロット刻みで req を【切り下げ】て返す関数。
    - req_raw : 戦略が希望する元の新規サイズ
    - abs_q   : いまの在庫の絶対値 |Q|
    - eff_limit : 実効在庫上限（例：max_inventory * 0.99）
    - min_lot : 取引所の最小ロット刻み
    - target_ratio : 目標比（既定=0.90）。( |Q|+req ) / eff_limit ≤ 目標 になるよう制御

    戻り値:
      ・発注可能なら、刻みを満たしたサイズ（req_raw 以下に切り下げ）
      ・発注不可なら 0.0（この場合は上流で新規をスキップ/ROだけにする）
    """
    # 非常時・異常値の安全側
    if req_raw <= 0.0 or eff_limit <= 0.0 or min_lot <= 0.0 or target_ratio <= 0.0:
        return 0.0

    # 1) 目標以内で追加できる“最大許容増分”を計算（負なら新規ゼロ）
    allowed_add = target_ratio * eff_limit - abs_q
    if allowed_add <= 0.0:
        return 0.0

    # 2) ロット刻みに合わせて“切り下げ”し、元の希望サイズとも比較
    #    （切り上げ禁止＝規約超過や在庫超過を防ぐ）
    allowed_lots = math.floor(allowed_add / min_lot)
    if allowed_lots <= 0:
        return 0.0
    allowed_size = allowed_lots * min_lot

    # 3) 実際に出すサイズは「元の希望」か「許容サイズ」の小さい方
    sized = min(req_raw, allowed_size)

    # 4) ごく小さい端数（浮動小数誤差等）を安全に丸め落とし
    lots = math.floor(sized / min_lot)
    if lots <= 0:
        return 0.0
    return lots * min_lot


def inv_capping_preflight(
    *,
    req_raw: float,
    abs_q: float,
    eff_limit: float,
    min_lot: float,
    target_ratio: float = 0.90,
    cfg_path: str | None = None,
) -> tuple[float, bool]:
    """
    在庫ガード直前の“在庫連動ロット”前処理。
    - 入力: req_raw（希望サイズ）, abs_q（現|Q|）, eff_limit（実効上限）, min_lot, target_ratio
    - 出力: (safe_size, should_skip)
      should_skip=True の場合は固定文言で DEBUG を記録済み。
    """
    # 関数内インポート（トップの import 変更を避ける）
    from loguru import logger  # 在庫由来スキップの固定文言をDEBUGで残す（集計用）

    try:
        eff = float(eff_limit)
        lotsz = float(min_lot)
        tgt = float(target_ratio)
        rq = float(req_raw)
        aq = float(abs_q)
    except Exception:
        return 0.0, True

    safe_size = cap_order_size_by_inventory(
        req_raw=rq,
        abs_q=aq,
        eff_limit=eff,
        min_lot=lotsz,
        target_ratio=tgt,
    )
    r_pre = (aq + rq) / eff if eff > 0 else float("inf")
    # headroomの観測ログ（target_ratio×eff_limit 基準）
    target_eff = tgt * eff
    headroom = max(target_eff - aq, 0.0)
    try:
        logger.debug(
            "inv_capping.headroom | abs_q={:.6f} target_eff={:.6f} headroom={:.6f} cfg_path={}",
            aq, target_eff, headroom, (cfg_path or "n/a"),
        )
    except Exception:
        pass

    # 観測イベントを1件カウント（60秒でINFO集計）
    try:
        _inv_cap_rollup_count("event", eff, (cfg_path or "n/a"))
    except Exception:
        pass

    # 余地ゼロ、または丸め後も上限超過 → 固定文言で見送り
    if (safe_size <= 0.0) or ((aq + safe_size) > eff):
        logger.debug(
            "skip place: capped_by_inventory (no_room) | r_pre={:.3f} abs_q={:.6f} req_raw={:.6f} eff_limit={:.6f} target={:.2f} headroom={:.6f} cfg_path={}",
            r_pre, aq, rq, eff, tgt, headroom, (cfg_path or "n/a"),
        )
        # 余地ゼロ件数をカウント（60秒でINFO集計）
        try:
            _inv_cap_rollup_count("no_room", eff, (cfg_path or "n/a"))
        except Exception:
            pass
        return 0.0, True

    # 縮小の可視化（DEBUG）
    if safe_size < (rq - 1e-12):
        logger.debug(
            "capped_by_inventory | r_pre={:.3f} -> r_post={:.3f} size:{:.6f}->{:.6f} headroom={:.6f} cfg_path={}",
            r_pre, (aq + safe_size) / eff if eff > 0 else float("inf"), rq, safe_size, headroom, (cfg_path or "n/a"),
        )
        # 実縮小件数をカウント（60秒でINFO集計）
        try:
            _inv_cap_rollup_count("shrink", eff, (cfg_path or "n/a"))
        except Exception:
            pass
